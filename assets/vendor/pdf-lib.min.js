(function () {
  const encodePdfString = (text) => String(text).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");

  class PdfPage {
    constructor(size) {
      this.size = size;
      this.texts = [];
    }

    drawText(text, options = {}) {
      this.texts.push({ text, options });
    }
  }

  class PdfDocument {
    constructor() {
      this.pages = [];
    }

    static async create() {
      return new PdfDocument();
    }

    addPage(size) {
      const page = new PdfPage(size);
      this.pages.push(page);
      return page;
    }

    async embedFont(fontName) {
      return { name: fontName };
    }

    async save() {
      const encoder = new TextEncoder();
      const byteLength = (text) => encoder.encode(text).length;

      const objects = [];
      const addObject = (content) => {
        objects.push(content);
        return objects.length;
      };

      const fontId = addObject("<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>");

      const pageIds = this.pages.map((page) => {
        const contentStream = page.texts
          .map((entry) => {
            const size = entry.options.size || 12;
            const x = entry.options.x || 50;
            const y = entry.options.y || 700;
            return `BT /F1 ${size} Tf ${x} ${y} Td (${encodePdfString(entry.text)}) Tj ET`;
          })
          .join("\n");

        const contentId = addObject(`<< /Length ${byteLength(contentStream)} >>\nstream\n${contentStream}\nendstream`);

        const pageObj = [
          "<< /Type /Page",
          `/Parent 0 0 R`,
          `/Resources << /Font << /F1 ${fontId} 0 R >> >>`,
          `/MediaBox [0 0 ${page.size[0]} ${page.size[1]}]`,
          `/Contents ${contentId} 0 R`,
          ">>"
        ].join(" ");

        return addObject(pageObj);
      });

      const pagesId = addObject(`<< /Type /Pages /Kids [${pageIds.map((id) => `${id} 0 R`).join(" ")}] /Count ${pageIds.length} >>`);

      const fixedObjects = objects.map((obj, index) => {
        if (obj.includes("/Parent 0 0 R")) {
          return obj.replace("/Parent 0 0 R", `/Parent ${pagesId} 0 R`);
        }
        return obj;
      });

      const catalogId = addObject(`<< /Type /Catalog /Pages ${pagesId} 0 R >>`);

      const pdfChunks = ["%PDF-1.4\n"];
      const offsets = [0];
      let byteCount = byteLength(pdfChunks[0]);

      fixedObjects.forEach((obj, index) => {
        offsets.push(byteCount);
        const chunk = `${index + 1} 0 obj\n${obj}\nendobj\n`;
        pdfChunks.push(chunk);
        byteCount += byteLength(chunk);
      });

      const xrefStart = byteCount;
      let xref = `xref\n0 ${fixedObjects.length + 1}\n0000000000 65535 f \n`;
      offsets.slice(1, fixedObjects.length + 1).forEach((offset) => {
        xref += `${String(offset).padStart(10, "0")} 00000 n \n`;
      });
      pdfChunks.push(xref);
      byteCount += byteLength(xref);

      const trailer = `trailer\n<< /Size ${fixedObjects.length + 1} /Root ${catalogId} 0 R >>\nstartxref\n${xrefStart}\n%%EOF`;
      pdfChunks.push(trailer);

      return encoder.encode(pdfChunks.join(""));
    }
  }

  const rgb = (r, g, b) => ({ r, g, b });

  window.PDFLib = {
    PDFDocument: PdfDocument,
    StandardFonts: {
      Helvetica: "Helvetica",
      HelveticaBold: "Helvetica-Bold"
    },
    rgb
  };
})();
